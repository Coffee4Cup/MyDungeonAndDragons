package D_D.Units;

import D_D.Level;
import D_D.RandomGenerator.RandomGenerator;
import org.jetbrains.annotations.NotNull;

public abstract class Unit implements ChangeWithTick {

    protected static final int RESET_VALUE = 0;

    protected RandomGenerator randomGenerator;
    protected String name;
    protected int healthPool;
    protected int currentHealth;
    protected int attackPoints;
    protected int defensePoints;
    protected Position position;
    protected Level currentGameLevel;

    public Unit(String name, int healthPool, int currentHealth, int attackPoints, int defensePoints, Position position, RandomGenerator randomGenerator) {
        
        this.name = name;
        this.healthPool = healthPool;
        this.currentHealth = currentHealth;
        this.attackPoints = attackPoints;
        this.defensePoints = defensePoints;
        this.position = position;
        this.randomGenerator = randomGenerator;
    }

    public void setCurrentGameLevel(Level currentGameLevel) {
        this.currentGameLevel = currentGameLevel;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getHealthPool() {
        return healthPool;
    }

    public void setHealthPool(int healthPool) {
        this.healthPool = healthPool;
    }

    public int getCurrentHealth() {
        return currentHealth;
    }

    public void setCurrentHealth(int currentHealth) {
        this.currentHealth = currentHealth;
    }

    public int getAttackPoints() {
        return attackPoints;
    }

    public void setAttackPoints(int attackPoints) {
        this.attackPoints = attackPoints;
    }

    public int getDefensePoints() {
        return defensePoints;
    }

    public void setDefensePoints(int defensePoints) {
        this.defensePoints = defensePoints;
    }

    public Position getPosition() {
        return position;
    }

    public void setPosition(Position position) {
        this.position = position;
    }

    public void takeTurn() {
        takeAction();
    }

    /**
     * The action the unit preforms on her turn in the game tick.
     */
    protected abstract void takeAction();


    @Override
    public String toString() {
        return
                "name='" + name + '\'' +
                        ", healthPool=" + healthPool +
                        ", currentHealth=" + currentHealth +
                        ", AttackPoints=" + attackPoints +
                        ", DefensePoints=" + defensePoints +
                        ", position=" + position;
    }

    /**
     * returns
     * returns the damage this Unit generate. the damage is randomly generated by the class the implements the "RandomGenerator interface"/
     *
     * @param maxHitDamage the maximum damage that this specific attack can output.
     * @return the actual damage that the attack outputs
     */
    public int rollAttack(int maxHitDamage) {
        return randomGenerator.nextInt(maxHitDamage);
    }

    /**
     * returns
     * returns the damage this Unit generate. the damage is randomly generated by the class the implements the "RandomGenerator interface"/
     *
     * @return the actual defence that the defender outputs
     */
    public int rollDefence() {
        return randomGenerator.nextInt(defensePoints);
    }

    /**
     * the general process a unit hits another unit
     *
     * @param defender the defending unit
     * @param maxHitDamage the maximum damage the attacking unit can preform.
     */
    public void hit(@NotNull Unit defender, int maxHitDamage) {
        int rolledAttack = this.rollAttack(maxHitDamage);
        int rolledDefence = defender.rollDefence();
        defender.healthPool -= rolledAttack - rolledDefence;
    }

    /**
     * the hit a unit preforms when it attempts to walk on a tile a hostile unit is trying to walk on.
     */
    public void basicHit(Unit defender) {
        hit(defender, attackPoints);
    }

    public Level getCurrentGameLevel() {
        return currentGameLevel;//@todo implement an observer Pattern for the player to get upddated whenever the game is moving level
    }
}
